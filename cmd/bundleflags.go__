// Copyright Â© 2017 Max Goltzsche
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"path/filepath"
	"strconv"
	"strings"

	"github.com/mgoltzsche/cntnr/generate"
	"github.com/opencontainers/runtime-spec/specs-go"
	"github.com/opencontainers/runtime-tools/validate"
	"github.com/spf13/pflag"
)

var flagsBundle = bundleFlags{}

func initBundleRunFlags(f *pflag.FlagSet) {
	f.BoolVarP(&flagsBundle.Stdin, "stdin", "i", false, "binds stdin to the container")
}

func initBundleCreateFlags(f *pflag.FlagSet) {
	b := &flagsBundle
	f.StringVar(&b.Name, "name", "", "container name. Also used as hostname when hostname is not set explicitly")
	f.Var((*bEntrypoint)(b), "entrypoint", "container entrypoint")
	f.VarP((*bCwd)(b), "workdir", "w", "container entrypoint")
	f.VarP((*bEnvironment)(b), "env", "e", "container environment variables")
	f.Var((*bCapAdd)(b), "cap-add", "add process capability ('all' adds all)")
	f.Var((*bCapDrop)(b), "cap-drop", "drop process capability ('all' drops all)")
	f.StringVar(&b.seccomp, "seccomp", "", "seccomp profile file or 'default' or 'unconfined'")
	f.Var((*bMountCgroups)(b), "mount-cgroups", "Mounts the host's cgroups with the given option: ro|rw|no")
	f.VarP((*bBindMount)(b), "volume", "v", "container volume mounts: TARGET|SOURCE:TARGET[:OPTIONS]")
	f.Var((*bExpose)(b), "expose", "container ports to be exposed")
	f.BoolVar(&b.readonly, "readonly", false, "mounts the root file system in read only mode")
	f.BoolVarP(&b.tty, "tty", "t", false, "binds a terminal to the container")
	f.StringSliceVar(&b.networks, "net", nil, "add CNI network to container's network namespace")
	initNetFlags(f)
	// Stop parsing after first non flag argument (image)
	f.SetInterspersed(false)
}

type bundleFlags struct {
	Name             string
	Image            string
	Stdin            bool
	tty              bool
	readonly         bool
	dropCapabilities bool
	seccomp          string
	networks         []string
	build            []func(*generate.SpecBuilder) error
}

func (f *bundleFlags) add(build func(*generate.SpecBuilder) error) {
	f.build = append(f.build, build)
}

func (f *bundleFlags) setBundleArgs(args []string) error {
	if len(args) == 0 {
		return usageError("No image arg specified")
	}
	f.Image = args[0]
	if len(args) > 1 {
		(*bundleFlags)(f).add(func(b *generate.SpecBuilder) error {
			b.SetProcessCmd(args[1:])
			return nil
		})
	}
	return nil
}

func (f *bundleFlags) Apply(spec *generate.SpecBuilder) (err error) {
	spec.SetHostname(flagHostname)

	for _, b := range f.build {
		if err = b(spec); err != nil {
			return
		}
	}

	spec.SetRootReadonly(f.readonly)
	spec.SetProcessTerminal(f.tty)

	// Add network config
	hook, err := generate.NewHookBuilderFromSpec(spec.Spec())
	if err != nil {
		return
	}
	hook.SetDomainname(flagDomainname)
	for _, net := range f.networks {
		hook.AddNetwork(net)
	}
	for _, dnsip := range flagDns {
		hook.AddDnsNameserver(dnsip)
	}
	for _, search := range flagDnsSearch {
		hook.AddDnsSearch(search)
	}
	for _, opt := range flagDnsOptions {
		hook.AddDnsOption(opt)
	}
	for _, e := range flagHostsEntries {
		hook.AddHost(e.name, e.ip)
	}
	for _, p := range flagPorts {
		hook.AddPortMapEntry(generate.PortMapEntry{
			Target:    p.HostPort,
			Published: p.ContainerPort,
			Protocol:  p.Protocol,
			IP:        p.HostIP,
		})
	}
	if err = hook.Build(&spec.Generator); err != nil {
		return
	}

	// Drop capabilities
	if f.dropCapabilities {
		spec.DropAllProcessCapabilities()
	}

	// Seccomp
	if f.seccomp == "" || f.seccomp == "default" {
		// Derive seccomp configuration (must be called as last)
		spec.SetLinuxSeccompDefault()
	} else if f.seccomp == "unconfined" {
		// Do not restrict operations with seccomp
		spec.SetLinuxSeccompUnconfined()
	} else {
		// Use seccomp configuration from file
		var j []byte
		if j, err = ioutil.ReadFile(f.seccomp); err != nil {
			return
		}
		seccomp := &specs.LinuxSeccomp{}
		if err = json.Unmarshal(j, seccomp); err != nil {
			return
		}
		spec.SetLinuxSeccomp(seccomp)
	}

	flagHostname = ""
	flagDomainname = ""
	flagDns = nil
	flagDnsSearch = nil
	flagDnsOptions = nil
	flagHostsEntries = nil
	flagPorts = nil
	f.Image = ""
	f.seccomp = ""
	f.dropCapabilities = false
	f.build = nil
	return
}

type bEntrypoint bundleFlags

func (b *bEntrypoint) Set(s string) (err error) {
	entrypoint, err := parseStringEntries(s)
	(*bundleFlags)(b).add(func(b *generate.SpecBuilder) error {
		b.SetProcessEntrypoint(entrypoint)
		return nil
	})
	return
}

func (b *bEntrypoint) Type() string {
	return "cmd"
}

func (b *bEntrypoint) String() string {
	return ""
}

type bCwd bundleFlags

func (b *bCwd) Set(s string) error {
	(*bundleFlags)(b).add(func(b *generate.SpecBuilder) error {
		b.SetProcessCwd(s)
		return nil
	})
	return nil
}

func (b *bCwd) Type() string {
	return "dir"
}

func (b *bCwd) String() string {
	return ""
}

type bEnvironment bundleFlags

func (b *bEnvironment) Set(s string) error {
	(*bundleFlags)(b).add(func(b *generate.SpecBuilder) error {
		env := strings.SplitN(s, "=", 2)
		v := ""
		if len(env) > 1 {
			v = env[1]
		}
		b.AddProcessEnv(env[0], v)
		return nil
	})
	return nil
}

func (b *bEnvironment) Type() string {
	return "NAME=VALUE..."
}

func (b *bEnvironment) String() string {
	return ""
}

type bCapAdd bundleFlags

func (b *bCapAdd) Set(c string) (err error) {
	if strings.ToUpper(c) != "ALL" {
		err = validate.CapValid(c, false)
	}
	(*bundleFlags)(b).add(func(b *generate.SpecBuilder) (err error) {
		if strings.ToUpper(c) == "ALL" {
			b.AddAllProcessCapabilities()
		} else {
			err = b.AddProcessCapability(c)
		}
		return
	})
	return
}

func (b *bCapAdd) Type() string {
	return "list"
}

func (b *bCapAdd) String() string {
	return ""
}

type bCapDrop bundleFlags

func (b *bCapDrop) Set(c string) (err error) {
	if strings.ToUpper(c) == "ALL" {
		b.dropCapabilities = true
	} else {
		err = validate.CapValid(c, false)
		(*bundleFlags)(b).add(func(b *generate.SpecBuilder) (err error) {
			return b.DropProcessCapability(c)
		})
	}
	return
}

func (b *bCapDrop) Type() string {
	return "list"
}

func (b *bCapDrop) String() string {
	return ""
}

type bMountCgroups bundleFlags

func (b *bMountCgroups) Set(opt string) error {
	switch opt {
	case "ro":
	case "rw":
	case "no":
	default:
		return fmt.Errorf("value should be one of (ro,rw,no)")
	}
	(*bundleFlags)(b).add(func(b *generate.SpecBuilder) error {
		return b.AddCgroupsMount(opt)
	})
	return nil
}

func (b *bMountCgroups) Type() string {
	return "string"
}

func (b *bMountCgroups) String() string {
	return ""
}

type bExpose bundleFlags

func (b *bExpose) Set(s string) (err error) {
	if s == "" {
		return
	}
	ports := make([]string, 0, 1)
	for _, port := range strings.Split(s, " ") {
		if port != "" {
			if _, err = strconv.Atoi(s); err != nil {
				return
			}
			ports = append(ports, port)
		}
	}
	(*bundleFlags)(b).add(func(b *generate.SpecBuilder) error {
		b.AddExposedPorts(ports)
		return nil
	})
	return nil
}

func (b *bExpose) Type() string {
	return "port..."
}

func (b *bExpose) String() string {
	return ""
}

type bBindMount bundleFlags

func (b *bBindMount) Set(s string) (err error) {
	m, err := parseVolumeMount(s)
	if m.Source, err = filepath.Abs(m.Source); err != nil {
		return
	}
	(*bundleFlags)(b).add(func(b *generate.SpecBuilder) (err error) {
		b.AddBindMount(m.Source, m.Destination, m.Options)
		return nil
	})
	return
}

func (b *bBindMount) Type() string {
	return "string..."
}

func (b *bBindMount) String() string {
	return ""
}

func parseVolumeMount(expr string) (r specs.Mount, err error) {
	r.Options = []string{}
	s := strings.Split(expr, ":")
	switch len(s) {
	case 1:
		r.Source = ""
		r.Destination = s[0]
	default:
		r.Source = s[0]
		r.Destination = s[1]
		r.Options = s[2:]
	}
	if r.Destination == "" {
		err = fmt.Errorf("No volume mount target specified: %s", expr)
	}
	return
}
