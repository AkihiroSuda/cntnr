package store

import (
	"bytes"
	"encoding/base32"
	"io/ioutil"
	"os"
	"path/filepath"

	"github.com/mgoltzsche/cntnr/oci/image"
	"github.com/mgoltzsche/cntnr/pkg/atomic"
	exterrors "github.com/mgoltzsche/cntnr/pkg/errors"
	digest "github.com/opencontainers/go-digest"
	"github.com/pkg/errors"
)

var _ image.ImageTagStore = &ImageTagStore{}

type ImageTagStore struct {
	dir string
}

func NewImageTagStore(dir string) (r ImageTagStore, err error) {
	r.dir = dir
	return
}

func (s *ImageTagStore) AddTag(name string, imageID digest.Digest) (err error) {
	defer exterrors.Wrapdf(&err, "add tag %q", name)

	if err = imageID.Validate(); err != nil {
		return errors.Wrap(err, "image ID")
	}
	if err = os.MkdirAll(s.dir, 0775); err != nil {
		return
	}
	file, err := s.tagFile(name)
	if err == nil {
		_, err = atomic.WriteFile(file, bytes.NewBufferString(imageID.String()))
	}
	return
}

func (s *ImageTagStore) DelTag(name string) error {
	file, err := s.tagFile(name)
	if err == nil {
		err = os.Remove(file)
	}
	return errors.Wrap(err, "remove tag")
}

func (s *ImageTagStore) Tag(name string) (t image.Tag, err error) {
	file, err := s.tagFile(name)
	if err == nil {
		t.Name = image.TagName{name, "latest"} // TODO: parse ref
		t.ImageID, err = readTagImageID(file)
	}
	return t, errors.Wrapf(err, "tag %q", name)
}

func (s *ImageTagStore) Tags() (t []image.Tag, err error) {
	fl, err := ioutil.ReadDir(s.dir)
	if err != nil && !os.IsNotExist(err) {
		return t, errors.Wrap(err, "tags")
	}
	t = make([]image.Tag, 0, len(fl))
	if len(fl) > 0 {
		for _, f := range fl {
			if !f.IsDir() {
				name, e := decodeTagFileName(f.Name())
				if e == nil {
					tag, e := s.Tag(name)
					if e == nil {
						t = append(t, tag)
					} else if err == nil {
						err = e
					}
				}
			}
		}
	}
	return
}

func (s *ImageTagStore) tagFile(name string) (string, error) {
	if name == "" || filepath.Clean(name) == "." {
		return "", errors.Errorf("resolve tag file: empty name provided")
	}
	return filepath.Join(s.dir, base32.StdEncoding.EncodeToString([]byte(name))), nil
}

/*func (s *ImageTagStore) tagName(file string) (name string, err error) {
	return decodeTagFileName(filepath.Base(file))
}*/

func decodeTagFileName(fileName string) (string, error) {
	name, err := base32.StdEncoding.DecodeString(fileName)
	return string(name), errors.Wrapf(err, "decode tag file %q", fileName)
}

func readTagImageID(file string) (imageID digest.Digest, err error) {
	f, err := os.Open(file)
	if err != nil {
		return
	}
	defer f.Close()
	b, err := ioutil.ReadAll(f)
	if err != nil {
		return
	}
	imageID, err = digest.Parse(string(b))
	return
}
