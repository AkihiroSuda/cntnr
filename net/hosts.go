package net

import (
	"fmt"
	"os"
	"sort"
	"strings"
)

/*
func writeHostnameAndHostsFiles(pid int, rootfs, hostname, ifName string, customHosts map[string]string) error {
	if hostname == "" {
		return fmt.Errorf("No hostname specified")
	}
	if ifName == "" {
		return fmt.Errorf("No network interface specified")
	}

	// Get rootfs from bundle
	etcDir := filepath.Join(rootfs, "etc")
	if _, err := os.Stat(etcDir); os.IsNotExist(err) {
		err = os.Mkdir(etcDir, 0755)
		if err != nil {
			return err
		}
	}

	// Separate domainname from hostname
	domainname := ""
	dotPos := strings.Index(hostname, ".")
	if dotPos != -1 {
		domainname = hostname[dotPos+1:]
		hostname = hostname[:dotPos]
	}

	// Enter container's network namespace (to be able to read IP)
	runtime.LockOSThread()
	defer runtime.UnlockOSThread()
	ns, err := netns.GetFromPid(pid)
	if err != nil {
		return fmt.Errorf("Cannot find network namespace of process with PID %d: %s", pid, err)
	}
	currns := netns.Get()
	err := netns.Set(ns)
	if err != nil {
		return fmt.Errorf("Could not enter container netns: %s", err)
	}
	defer netns.Set(currns)

	// Get container IP and write corresponding /etc/hosts
	ifIP, err := getIP(ifName)
	if err != nil {
		return err
	}
	hosts := defaultHosts()
	if domainname == "" {
		hosts[ifIP] = hostname + " " + hosts[ifIP]
	} else {
		hosts[ifIP] = hostname + "." + domainname + " " + hostname + " " + hosts[ifIP]
	}
	for ip, names := range customHosts {
		hosts[ip] = names + " " + hosts[ip]
	}
	return writeHostsFile(filepath.Join(etcDir, "hosts"), hosts)
}
*/

func writeHostsFile(dest string, hosts map[string]string) error {
	uniq := map[string]string{}
	entries := make([]string, len(hosts))
	i := 0
	for ip, names := range hosts {
		for _, n := range strings.Split(strings.Trim(names, " "), " ") {
			if mip, ok := uniq[n]; ok {
				return fmt.Errorf("Ambiguous hostname mapping. Hostname %q points to IPs: %s, %s", n, mip, ip)
			}
			uniq[n] = ip
		}
		entries[i] = fmt.Sprintf("%-15s  %s", ip, strings.Trim(names, " "))
		i++
	}
	sort.Strings(entries)

	hc := "# Generated by " + os.Args[0] + "\n" + strings.Join(entries, "\n") + "\n"
	err := writeFile(dest, hc)
	if err != nil {
		return fmt.Errorf("Cannot write hosts file: %s", err)
	}
	return nil
}

func defaultHosts() map[string]string {
	return map[string]string{
		"127.0.0.1": "localhost localhost.domain localhost4 localhost4.localdomain4",
		"::1":       "ip6-localhost ip6-loopback localhost6 localhost6.localdomain6",
		"fe00::0":   "ip6-localnet",
		"ff00::0":   "ip6-mcastprefix",
		"ff02::1":   "ip6-allnodes",
		"ff02::2":   "ip6-allrouters",
		"ff02::3":   "ip6-allhosts",
	}
}
