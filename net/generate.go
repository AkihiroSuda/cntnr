package net

import (
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

type ConfigFileGenerator struct {
	ip            string
	hostname      string
	domainname    string
	dnsNameserver []string
	dnsSearch     []string
	dnsOptions    []string
	hosts         map[string]string
	hostsOrder    []string
}

func NewConfigFileGenerator() *ConfigFileGenerator {
	return &ConfigFileGenerator{
		dnsNameserver: []string{},
		dnsSearch:     []string{},
		dnsOptions:    []string{},
		hosts:         map[string]string{},
		hostsOrder:    []string{},
	}
}

func (b *ConfigFileGenerator) SetHostname(hostname string) {
	dotPos := strings.Index(hostname, ".")
	if dotPos > 0 && dotPos+1 < len(hostname) {
		b.hostname = hostname[:dotPos]
		b.domainname = hostname[dotPos+1:]
	} else {
		b.hostname = hostname
	}
}

func (b *ConfigFileGenerator) SetDomainname(domainname string) {
	b.domainname = domainname
}

func (b *ConfigFileGenerator) SetMainIP(ip string) {
	b.ip = ip
}

func (b *ConfigFileGenerator) AddHostsEntry(host, ip string) {
	b.hostsOrder = append(b.hostsOrder, host)
	b.hosts[host] = ip
}

func (b *ConfigFileGenerator) AddDnsNameserver(dns []string) {
	if len(dns) > 0 {
		b.dnsNameserver = append(b.dnsNameserver, dns...)
	}
}

func (b *ConfigFileGenerator) AddDnsSearch(searchSuffix []string) {
	if len(searchSuffix) > 0 {
		b.dnsSearch = append(b.dnsSearch, searchSuffix...)
	}
}

func (b *ConfigFileGenerator) AddDnsOptions(opts []string) {
	if len(opts) > 0 {
		b.dnsOptions = append(b.dnsOptions, opts...)
	}
}

func (b *ConfigFileGenerator) Apply(rootfs string) error {
	// Create /etc dir in bundle's rootfs
	etcDir := filepath.Join(rootfs, "etc")
	if _, err := os.Stat(etcDir); os.IsNotExist(err) {
		if err = os.Mkdir(etcDir, 0755); err != nil {
			return err
		}
	}
	hostnameFile := filepath.Join(etcDir, "hostname")
	hostsFile := filepath.Join(etcDir, "hosts")
	resolvConfFile := filepath.Join(etcDir, "resolv.conf")

	// Write /etc/hostname
	hostname := b.hostname
	if hostname != "" {
		if err := writeFile(hostnameFile, hostname+"\n"); err != nil {
			return fmt.Errorf("Cannot write hostname file: %s", err)
		}
	}

	// Write /etc/resolv.conf if value set
	if err := b.writeResolvConf(resolvConfFile); err != nil {
		return err
	}

	// Write /etc/hosts if not empty
	return b.writeHosts(hostsFile)
}

func (b *ConfigFileGenerator) writeResolvConf(dest string) error {
	rc := ""

	for _, ns := range b.dnsNameserver {
		rc += "nameserver " + ns + "\n"
	}

	for _, s := range b.dnsSearch {
		rc += "search " + s + "\n"
	}

	if b.domainname != "" {
		rc += "domain " + b.domainname + "\n"
	}

	if len(b.dnsOptions) > 0 {
		rc += "options " + strings.Join(b.dnsOptions, " ") + "\n"
	}

	if rc != "" {
		rc = "# Generated by " + os.Args[0] + "\n" + rc
		return writeFile(dest, rc)
	}
	return nil
}

func (b *ConfigFileGenerator) writeHosts(dest string) error {
	if len(b.hosts) == 0 && b.hostname == "" {
		return nil
	}

	hosts := map[string]string{
		"127.0.0.1": "localhost localhost.localdomain localhost.domain localhost4 localhost4.localdomain4",
		"::1":       "ip6-localhost ip6-loopback localhost6 localhost6.localdomain6",
		"fe00::0":   "ip6-localnet",
		"ff00::0":   "ip6-mcastprefix",
		"ff02::1":   "ip6-allnodes",
		"ff02::2":   "ip6-allrouters",
		"ff02::3":   "ip6-allhosts",
	}
	if b.ip != "" && b.hostname != "" {
		if b.domainname == "" {
			hosts[b.ip] = strings.Trim(b.hostname+" "+hosts[b.ip], " ")
		} else {
			hosts[b.ip] = strings.Trim(b.hostname+"."+b.domainname+" "+b.hostname+" "+hosts[b.ip], " ")
		}
	}
	for _, name := range b.hostsOrder {
		ip := b.hosts[name]
		hosts[ip] = strings.Trim(hosts[ip]+" "+name, " ")
	}
	entries := make([]string, len(hosts))
	i := 0
	for ip, names := range hosts {
		entries[i] = fmt.Sprintf("%-15s  %s", ip, names)
		i++
	}
	sort.Strings(entries)

	hc := "# Generated by " + os.Args[0] + "\n" + strings.Join(entries, "\n") + "\n"
	err := writeFile(dest, hc)
	if err != nil {
		return fmt.Errorf("Cannot write hosts file: %s", err)
	}
	return nil
}

func writeFile(dest, content string) error {
	f, err := os.OpenFile(dest, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, 0644)
	if err != nil {
		return err
	}
	if _, err := f.Write([]byte(content)); err != nil {
		f.Close()
		return err
	}
	return f.Close()
}
